/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export type paths = {
  "/public/v1/query/get_activity": {
    /** Get details about an Activity */
    post: operations["PublicApiService_GetActivity"];
  };
  "/public/v1/query/get_organization": {
    /** Get details about an Organization */
    post: operations["PublicApiService_GetOrganization"];
  };
  "/public/v1/query/get_policy": {
    /** Get details about a Policy */
    post: operations["PublicApiService_GetPolicy"];
  };
  "/public/v1/query/get_user": {
    /** Get details about a User */
    post: operations["PublicApiService_GetUser"];
  };
  "/public/v1/query/list_activities": {
    /** List all Activities within an Organization */
    post: operations["PublicApiService_GetActivities"];
  };
  "/public/v1/query/list_policies": {
    /** List all Policies within an Organization */
    post: operations["PublicApiService_GetPolicies"];
  };
  "/public/v1/query/list_private_keys": {
    /** List all Private Keys within an Organization */
    post: operations["PublicApiService_GetPrivateKeys"];
  };
  "/public/v1/query/list_users": {
    /** List all Users within an Organization */
    post: operations["PublicApiService_GetUsers"];
  };
  "/public/v1/query/whoami": {
    /** Get basic information about your current API user and your organization */
    post: operations["PublicApiService_GetWhoami"];
  };
  "/public/v1/submit/create_api_keys": {
    /** Add api keys to an existing User */
    post: operations["PublicApiService_CreateApiKeys"];
  };
  "/public/v1/submit/create_invitations": {
    /** Create Invitations to join an existing Organization */
    post: operations["PublicApiService_CreateInvitations"];
  };
  "/public/v1/submit/create_policy": {
    /** Create a new Policy */
    post: operations["PublicApiService_CreatePolicy"];
  };
  "/public/v1/submit/create_private_keys": {
    /** Create new Private Keys */
    post: operations["PublicApiService_CreatePrivateKeys"];
  };
  "/public/v1/submit/create_users": {
    /** Create Users in an existing Organization */
    post: operations["PublicApiService_CreateUsers"];
  };
  "/public/v1/submit/delete_api_keys": {
    /** Remove api keys from a User */
    post: operations["PublicApiService_DeleteApiKeys"];
  };
  "/public/v1/submit/delete_invitations": {
    /** Delete an existing Invitation */
    post: operations["PublicApiService_DeleteInvitation"];
  };
  "/public/v1/submit/delete_policy": {
    /** Delete an existing Policy */
    post: operations["PublicApiService_DeletePolicy"];
  };
  "/public/v1/submit/sign_raw_payload": {
    /** Sign a raw payload with a Private Key */
    post: operations["PublicApiService_SignRawPayload"];
  };
  "/public/v1/submit/sign_transaction": {
    /** Sign a transaction with a Private Key */
    post: operations["PublicApiService_SignTransaction"];
  };
  "/tkhq/public/v1/query/get_private_key": {
    /** Get details about a Private Key */
    post: operations["PublicApiService_GetPrivateKey"];
  };
};

export type definitions = {
  datav1Tag: {
    /** @description Unique identifier for a given Tag. */
    tagId: string;
    /** @description Human-readable name for a Tag. */
    tagName: string;
    tagType: definitions["v1TagType"];
    createdAt: definitions["v1Timestamp"];
    updatedAt: definitions["v1Timestamp"];
  };
  /** @enum {string} */
  externaldatav1AccessType:
    | "ACCESS_TYPE_WEB"
    | "ACCESS_TYPE_API"
    | "ACCESS_TYPE_ALL";
  externaldatav1Address: {
    format?: definitions["externaldatav1AddressFormat"];
    address?: string;
  };
  /**
   * - ADDRESS_FORMAT_UNCOMPRESSED: 04<X_COORDINATE><Y_COORDINATE>
   *  - ADDRESS_FORMAT_COMPRESSED: 02 or 03, followed by the X coordinate
   *  - ADDRESS_FORMAT_ETHEREUM: Your standard Ethereum address (0x...). We apply EIP55 casing.
   *  - ADDRESS_FORMAT_BITCOIN_P2PKH: Bitcoin formats. See https://en.bitcoin.it/wiki/List_of_address_prefixes
   * @enum {string}
   */
  externaldatav1AddressFormat:
    | "ADDRESS_FORMAT_UNCOMPRESSED"
    | "ADDRESS_FORMAT_COMPRESSED"
    | "ADDRESS_FORMAT_ETHEREUM"
    | "ADDRESS_FORMAT_BITCOIN_P2PKH"
    | "ADDRESS_FORMAT_BITCOIN_P2PKH_TESTNET";
  /** @enum {string} */
  externaldatav1AuthenticatorTransport:
    | "AUTHENTICATOR_TRANSPORT_BLE"
    | "AUTHENTICATOR_TRANSPORT_INTERNAL"
    | "AUTHENTICATOR_TRANSPORT_NFC"
    | "AUTHENTICATOR_TRANSPORT_USB"
    | "AUTHENTICATOR_TRANSPORT_HYBRID";
  /**
   * @description Cryptographic Curve used to generate a given Private Key.
   * @enum {string}
   */
  externaldatav1Curve: "CURVE_SECP256K1";
  /** @enum {string} */
  externaldatav1Effect: "EFFECT_ALLOW" | "EFFECT_DENY";
  /**
   * @description Logical operators.
   * @enum {string}
   */
  externaldatav1Operator:
    | "OPERATOR_EQUAL"
    | "OPERATOR_MORE_THAN"
    | "OPERATOR_MORE_THAN_OR_EQUAL"
    | "OPERATOR_LESS_THAN"
    | "OPERATOR_LESS_THAN_OR_EQUAL"
    | "OPERATOR_CONTAINS"
    | "OPERATOR_NOT_EQUAL"
    | "OPERATOR_IN"
    | "OPERATOR_NOT_IN"
    | "OPERATOR_CONTAINS_ONE"
    | "OPERATOR_CONTAINS_ALL";
  externaldatav1Selector: {
    /** @description The resource being referenced within a policy (e.g., user.tags or activities.type). */
    subject: string;
    operator: definitions["externaldatav1Operator"];
    /** @description The specific parameter from the subject being referenced, like a specific user ID. */
    targets: string[];
  };
  /** @enum {string} */
  immutableactivityv1AccessType:
    | "ACCESS_TYPE_WEB"
    | "ACCESS_TYPE_API"
    | "ACCESS_TYPE_ALL";
  /**
   * - ADDRESS_FORMAT_UNCOMPRESSED: 04<X_COORDINATE><Y_COORDINATE>
   *  - ADDRESS_FORMAT_COMPRESSED: 02 or 03, followed by the X coordinate
   *  - ADDRESS_FORMAT_ETHEREUM: Your standard Ethereum address (0x...). We apply EIP55 casing.
   *  - ADDRESS_FORMAT_BITCOIN_P2PKH: Bitcoin formats. See https://en.bitcoin.it/wiki/List_of_address_prefixes
   * @enum {string}
   */
  immutableactivityv1AddressFormat:
    | "ADDRESS_FORMAT_UNCOMPRESSED"
    | "ADDRESS_FORMAT_COMPRESSED"
    | "ADDRESS_FORMAT_ETHEREUM"
    | "ADDRESS_FORMAT_BITCOIN_P2PKH"
    | "ADDRESS_FORMAT_BITCOIN_P2PKH_TESTNET";
  /**
   * @description Cryptographic Curve used to generate a given Private Key.
   * @enum {string}
   */
  immutableactivityv1Curve: "CURVE_SECP256K1";
  /** @enum {string} */
  immutableactivityv1Effect: "EFFECT_ALLOW" | "EFFECT_DENY";
  /** @enum {string} */
  immutableactivityv1Operator:
    | "OPERATOR_EQUAL"
    | "OPERATOR_MORE_THAN"
    | "OPERATOR_MORE_THAN_OR_EQUAL"
    | "OPERATOR_LESS_THAN"
    | "OPERATOR_LESS_THAN_OR_EQUAL"
    | "OPERATOR_CONTAINS"
    | "OPERATOR_NOT_EQUAL"
    | "OPERATOR_IN"
    | "OPERATOR_NOT_IN"
    | "OPERATOR_CONTAINS_ONE"
    | "OPERATOR_CONTAINS_ALL";
  immutableactivityv1Selector: {
    subject?: string;
    operator?: definitions["immutableactivityv1Operator"];
    target?: string;
  };
  /**
   * - TRANSACTION_TYPE_ETHEREUM: Unsigned Ethereum transaction, RLP-encoded and hex-encoded
   * @enum {string}
   */
  immutableactivityv1TransactionType: "TRANSACTION_TYPE_ETHEREUM";
  /** @enum {string} */
  immutablewebauthnv1AuthenticatorTransport:
    | "AUTHENTICATOR_TRANSPORT_BLE"
    | "AUTHENTICATOR_TRANSPORT_INTERNAL"
    | "AUTHENTICATOR_TRANSPORT_NFC"
    | "AUTHENTICATOR_TRANSPORT_USB"
    | "AUTHENTICATOR_TRANSPORT_HYBRID";
  protobufAny: {
    "@type"?: string;
  } & { [key: string]: unknown };
  rpcStatus: {
    /** Format: int32 */
    code?: number;
    message?: string;
    details?: definitions["protobufAny"][];
  };
  v1AcceptInvitationIntent: {
    /**
     * @inject_tag: validate:"required,uuid"
     * @description Unique identifier for a given Invitation object.
     */
    invitationId: string;
    /**
     * @inject_tag: validate:"required,uuid"
     * @description Unique identifier for a given User.
     */
    userId: string;
    authenticator: definitions["v1AuthenticatorParams"];
  };
  v1AcceptInvitationResult: {
    /** @description Unique identifier for a given Invitation. */
    invitationId: string;
    /** @description Unique identifier for a given User. */
    userId: string;
  };
  /** @description An action that can that can be taken within the Turnkey infrastructure. */
  v1Activity: {
    /** @description Unique identifier for a given Activity object. */
    id: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    status: definitions["v1ActivityStatus"];
    type: definitions["v1ActivityType"];
    intent: definitions["v1Intent"];
    result: definitions["v1Result"];
    /** @description A list of objects representing a particular User's approval or rejection of a Consensus request, including all relevant metadata. */
    votes: definitions["v1Vote"][];
    /** @description An artifact verifying a User's action. */
    fingerprint: string;
    canApprove: boolean;
    canReject: boolean;
    createdAt: definitions["v1Timestamp"];
    updatedAt: definitions["v1Timestamp"];
  };
  v1ActivityResponse: {
    activity: definitions["v1Activity"];
  };
  /**
   * @description The current processing status of an Activity.
   * @enum {string}
   */
  v1ActivityStatus:
    | "ACTIVITY_STATUS_CREATED"
    | "ACTIVITY_STATUS_PENDING"
    | "ACTIVITY_STATUS_COMPLETED"
    | "ACTIVITY_STATUS_FAILED"
    | "ACTIVITY_STATUS_CONSENSUS_NEEDED"
    | "ACTIVITY_STATUS_REJECTED";
  /**
   * @description Type of Activity, such as Add User, or Sign Transaction.
   * @enum {string}
   */
  v1ActivityType:
    | "ACTIVITY_TYPE_CREATE_API_KEYS"
    | "ACTIVITY_TYPE_CREATE_USERS"
    | "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS"
    | "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD"
    | "ACTIVITY_TYPE_CREATE_INVITATIONS"
    | "ACTIVITY_TYPE_ACCEPT_INVITATION"
    | "ACTIVITY_TYPE_CREATE_POLICY"
    | "ACTIVITY_TYPE_DISABLE_PRIVATE_KEY"
    | "ACTIVITY_TYPE_DELETE_USERS"
    | "ACTIVITY_TYPE_DELETE_API_KEYS"
    | "ACTIVITY_TYPE_DELETE_INVITATION"
    | "ACTIVITY_TYPE_DELETE_ORGANIZATION"
    | "ACTIVITY_TYPE_DELETE_POLICY"
    | "ACTIVITY_TYPE_CREATE_USER_TAG"
    | "ACTIVITY_TYPE_DELETE_USER_TAGS"
    | "ACTIVITY_TYPE_CREATE_ORGANIZATION"
    | "ACTIVITY_TYPE_SIGN_TRANSACTION"
    | "ACTIVITY_TYPE_APPROVE_ACTIVITY"
    | "ACTIVITY_TYPE_REJECT_ACTIVITY"
    | "ACTIVITY_TYPE_DELETE_AUTHENTICATORS"
    | "ACTIVITY_TYPE_CREATE_AUTHENTICATORS"
    | "ACTIVITY_TYPE_CREATE_PRIVATE_KEY_TAG"
    | "ACTIVITY_TYPE_DELETE_PRIVATE_KEY_TAGS"
    | "ACTIVITY_TYPE_CREATE_PAYMENT_METHOD";
  v1ApiKey: {
    credential: definitions["v1Credential"];
    /** @description Unique identifier for a given API Key. */
    apiKeyId: string;
    /** @description Human-readable name for an API Key. */
    apiKeyName: string;
    createdAt: definitions["v1Timestamp"];
    updatedAt: definitions["v1Timestamp"];
  };
  v1ApiKeyParams: {
    /**
     * @inject_tag: validate:"required,max=40"
     * @description Human-readable name for an API Key.
     */
    apiKeyName: string;
    /**
     * @inject_tag: validate:"hexadecimal,len=66"
     * @description The public component of a cryptographic key pair used to sign messages and transactions.
     */
    publicKey: string;
  };
  v1ApproveActivityIntent: {
    /**
     * @inject_tag: validate:"required"
     * @description An artifact verifying a User's action.
     */
    fingerprint: string;
  };
  v1Authenticator: {
    /** @description Types of transports that may be used by an Authenticator (e.g., USB, NFC, BLE). */
    transports: definitions["externaldatav1AuthenticatorTransport"][];
    attestationType: string;
    /** @description Identifier indicating the type of the Security Key. */
    aaguid: string;
    /** @description Unique identifier for a given User. */
    userId: string;
    /** @description Unique identifier for a WebAuthn credential. */
    credentialId: string;
    /** @description The type of Authenticator device. */
    model: string;
    credential: definitions["v1Credential"];
    /** @description Unique identifier for a given Authenticator. */
    authenticatorId: string;
    /** @description Human-readable name for an Authenticator. */
    authenticatorName: string;
    createdAt: definitions["v1Timestamp"];
    updatedAt: definitions["v1Timestamp"];
  };
  v1AuthenticatorAttestationResponse: {
    /** ENCODING: base64url */
    clientDataJson: string;
    /** ENCODING: base64url */
    attestationObject: string;
    transports?: definitions["immutablewebauthnv1AuthenticatorTransport"][];
    /** @enum {string} */
    authenticatorAttachment?: "cross-platform" | "platform" | null;
  };
  v1AuthenticatorParams: {
    /**
     * @inject_tag: validate:"required,max=40"
     * @description Human-readable name for an Authenticator.
     */
    authenticatorName: string;
    /**
     * @inject_tag: validate:"required,uuid"
     * @description Unique identifier for a given User.
     */
    userId: string;
    attestation: definitions["v1PublicKeyCredentialWithAttestation"];
    /**
     * @inject_tag: validate:"required,max=256"
     * @description Challenge presented for authentication purposes.
     */
    challenge: string;
  };
  v1CreateApiKeysIntent: {
    /**
     * @inject_tag: validate:"dive,required"
     * @description A list of API Keys.
     */
    apiKeys: definitions["v1ApiKeyParams"][];
    /**
     * @inject_tag: validate:"required,uuid"
     * @description Unique identifier for a given User.
     */
    userId: string;
  };
  v1CreateApiKeysRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_API_KEYS";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreateApiKeysIntent"];
  };
  v1CreateApiKeysResult: {
    /** @description A list of API Key IDs. */
    apiKeyIds: string[];
  };
  v1CreateAuthenticatorsIntent: {
    /**
     * @inject_tag: validate:"dive,required"
     * @description A list of Authenticators.
     */
    authenticators: definitions["v1AuthenticatorParams"][];
    /**
     * @inject_tag: validate:"required,uuid"
     * @description Unique identifier for a given User.
     */
    userId: string;
  };
  v1CreateAuthenticatorsResult: {
    /** @description A list of Authenticator IDs. */
    authenticatorIds: string[];
  };
  v1CreateInvitationsIntent: {
    /**
     * @inject_tag: validate:"required,dive,required"
     * @description A list of Invitations.
     */
    invitations: definitions["v1InvitationParams"][];
  };
  v1CreateInvitationsRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_INVITATIONS";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreateInvitationsIntent"];
  };
  v1CreateInvitationsResult: {
    /** @description A list of Invitation IDs */
    invitationIds: string[];
  };
  v1CreateOrganizationIntent: {
    /**
     * @inject_tag: validate:"required,max=40"
     * @description Human-readable name for an Organization.
     */
    organizationName: string;
    /**
     * @inject_tag: validate:"required,email"
     * @description The root user's email address.
     */
    rootEmail: string;
    rootAuthenticator: definitions["v1AuthenticatorParams"];
    /**
     * @inject_tag: validate:"uuid"
     * @description Unique identifier for the root user object.
     */
    rootUserId?: string;
  };
  v1CreateOrganizationResult: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
  };
  v1CreatePaymentMethodIntent: {
    /**
     * @inject_tag: validate:"required,max=16,numeric"
     * @description The account number of the customer's credit card.
     */
    number: string;
    /**
     * @inject_tag: validate:"required,max=4,numeric"
     * @description The verification digits of the customer's credit card.
     */
    cvv: string;
    /**
     * @inject_tag: validate:"required,numeric,len=2"
     * @description The month that the credit card expires.
     */
    expiryMonth: string;
    /**
     * @inject_tag: validate:"required,numeric,len=4"
     * @description The year that the credit card expires.
     */
    expiryYear: string;
    /**
     * @inject_tag: validate:"required,email"
     * @description The email that will receive invoices for the credit card.
     */
    cardHolderEmail: string;
    /**
     * @inject_tag: validate:"required,max=40"
     * @description The name associated with the credit card.
     */
    cardHolderName: string;
  };
  v1CreatePaymentMethodResult: {
    /** @description The last four digits of the credit card added. */
    lastFour: string;
    /** @description The name associated with the payment method. */
    cardHolderName: string;
    /** @description The email address associated with the payment method. */
    cardHolderEmail: string;
  };
  v1CreatePolicyIntent: {
    /**
     * @inject_tag: validate:"required,max=40"
     * @description Human-readable name for a Policy.
     */
    policyName: string;
    /**
     * @inject_tag: validate:"required,dive,required"
     * @description A list of simple functions each including a subject, target and boolean. See Policy Engine Language section for additional details.
     */
    selectors: definitions["immutableactivityv1Selector"][];
    effect: definitions["immutableactivityv1Effect"];
    notes?: string;
  };
  v1CreatePolicyIntentV2: {
    /**
     * @inject_tag: validate:"required,max=40"
     * @description Human-readable name for a Policy.
     */
    policyName: string;
    /**
     * @inject_tag: validate:"required,dive,required"
     * @description A list of simple functions each including a subject, target and boolean. See Policy Engine Language section for additional details.
     */
    selectors: definitions["v1SelectorV2"][];
    effect: definitions["immutableactivityv1Effect"];
    notes?: string;
  };
  v1CreatePolicyRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_POLICY";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreatePolicyIntentV2"];
  };
  v1CreatePolicyResult: {
    /** @description Unique identifier for a given Policy. */
    policyId: string;
  };
  v1CreatePrivateKeyTagIntent: {
    /**
     * @inject_tag: validate:"required,max=20"
     * @description Human-readable name for a Private Key Tag.
     */
    privateKeyTagName: string;
    /**
     * @inject_tag: validate:"dive,uuid"
     * @description A list of Private Key IDs.
     */
    privateKeyIds: string[];
  };
  v1CreatePrivateKeyTagResult: {
    /** @description Unique identifier for a given Private Key Tag. */
    privateKeyTagId: string;
    /** @description A list of Private Key IDs. */
    privateKeyIds: string[];
  };
  v1CreatePrivateKeysIntent: {
    /**
     * @inject_tag: validate:"dive,required"
     * @description A list of Private Keys.
     */
    privateKeys: definitions["v1PrivateKeyParams"][];
  };
  v1CreatePrivateKeysRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreatePrivateKeysIntent"];
  };
  v1CreatePrivateKeysResult: {
    /** @description A list of Private Key IDs. */
    privateKeyIds: string[];
  };
  v1CreateUserTagIntent: {
    /**
     * @inject_tag: validate:"required,max=20"
     * @description Human-readable name for a User Tag.
     */
    userTagName: string;
    /**
     * @inject_tag: validate:"dive,uuid"
     * @description A list of User IDs.
     */
    userIds: string[];
  };
  v1CreateUserTagResult: {
    /** @description Unique identifier for a given User Tag. */
    userTagId: string;
    /** @description A list of User IDs. */
    userIds: string[];
  };
  v1CreateUsersIntent: {
    /**
     * @inject_tag: validate:"required,dive,required"
     * @description A list of Users.
     */
    users: definitions["v1UserParams"][];
  };
  v1CreateUsersRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_CREATE_USERS";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1CreateUsersIntent"];
  };
  v1CreateUsersResult: {
    /** @description A list of User IDs. */
    userIds: string[];
  };
  v1CredPropsAuthenticationExtensionsClientOutputs: {
    rk: boolean;
  };
  v1Credential: {
    /** @description The public component of a cryptographic key pair used to sign messages and transactions. */
    publicKey: string;
    type: definitions["v1CredentialType"];
  };
  /** @enum {string} */
  v1CredentialType:
    | "CREDENTIAL_TYPE_WEBAUTHN_AUTHENTICATOR"
    | "CREDENTIAL_TYPE_API_KEY_P256";
  v1DeleteApiKeysIntent: {
    /**
     * @inject_tag: validate:"required,uuid"
     * @description Unique identifier for a given User.
     */
    userId: string;
    /**
     * @inject_tag: validate:"required,dive,required,uuid"
     * @description A list of API Key IDs.
     */
    apiKeyIds: string[];
  };
  v1DeleteApiKeysRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_DELETE_API_KEYS";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1DeleteApiKeysIntent"];
  };
  v1DeleteApiKeysResult: {
    /** @description A list of API Key IDs. */
    apiKeyIds: string[];
  };
  v1DeleteAuthenticatorsIntent: {
    /**
     * @inject_tag: validate:"required,uuid"
     * @description Unique identifier for a given User.
     */
    userId: string;
    /**
     * @inject_tag: validate:"required,div,required,uuid"
     * @description A list of Authenticator IDs.
     */
    authenticatorIds: string[];
  };
  v1DeleteAuthenticatorsResult: {
    /** @description Unique identifier for a given Authenticator. */
    authenticatorIds: string[];
  };
  v1DeleteInvitationIntent: {
    /**
     * @inject_tag: validate:"required,uuid"
     * @description Unique identifier for a given Invitation object.
     */
    invitationId: string;
  };
  v1DeleteInvitationRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_DELETE_INVITATION";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1DeleteInvitationIntent"];
  };
  v1DeleteInvitationResult: {
    /** @description Unique identifier for a given Invitation. */
    invitationId: string;
  };
  v1DeleteOrganizationIntent: {
    /**
     * @inject_tag: validate:"required,uuid"
     * @description Unique identifier for a given Organization.
     */
    organizationId: string;
  };
  v1DeleteOrganizationResult: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
  };
  v1DeletePolicyIntent: {
    /**
     * @inject_tag: validate:"required,uuid"
     * @description Unique identifier for a given Policy.
     */
    policyId: string;
  };
  v1DeletePolicyRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_DELETE_POLICY";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1DeletePolicyIntent"];
  };
  v1DeletePolicyResult: {
    /** @description Unique identifier for a given Policy. */
    policyId: string;
  };
  v1DeletePrivateKeyTagsIntent: {
    /**
     * @inject_tag: validate:"required,dive,required,uuid"
     * @description A list of Private Key Tag IDs.
     */
    privateKeyTagIds: string[];
  };
  v1DeletePrivateKeyTagsResult: {
    /** @description A list of Private Key Tag IDs. */
    privateKeyTagIds: string[];
    /** @description A list of Private Key IDs. */
    privateKeyIds: string[];
  };
  v1DeleteUserTagsIntent: {
    /**
     * @inject_tag: validate:"required,dive,required,uuid"
     * @description A list of User Tag IDs.
     */
    userTagIds: string[];
  };
  v1DeleteUserTagsResult: {
    /** @description A list of User Tag IDs. */
    userTagIds: string[];
    /** @description A list of User IDs. */
    userIds: string[];
  };
  v1DeleteUsersIntent: {
    /**
     * @inject_tag: validate:"required,dive,required,uuid"
     * @description A list of User IDs.
     */
    userIds: string[];
  };
  v1DeleteUsersResult: {
    /** @description A list of User IDs. */
    userIds: string[];
  };
  v1DisablePrivateKeyIntent: {
    /**
     * @inject_tag: validate:"required,uuid"
     * @description Unique identifier for a given Private Key.
     */
    privateKeyId: string;
  };
  v1DisablePrivateKeyResult: {
    /** @description Unique identifier for a given Private Key. */
    privateKeyId: string;
  };
  v1GetActivitiesRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    /** @description Array of Activity Statuses filtering which Activities will be listed in the response. */
    filterByStatus?: definitions["v1ActivityStatus"][];
  };
  v1GetActivitiesResponse: {
    /** @description A list of Activities. */
    activities: definitions["v1Activity"][];
  };
  v1GetActivityRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    /** @description Unique identifier for a given Activity object. */
    activityId: string;
  };
  v1GetOrganizationRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
  };
  v1GetOrganizationResponse: {
    organizationData: definitions["v1OrganizationData"];
  };
  v1GetPoliciesRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
  };
  v1GetPoliciesResponse: {
    /** @description A list of Policies. */
    policies: definitions["v1Policy"][];
  };
  v1GetPolicyRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    /** @description Unique identifier for a given Policy. */
    policyId: string;
  };
  v1GetPolicyResponse: {
    policy: definitions["v1Policy"];
  };
  v1GetPrivateKeyRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    /** @description Unique identifier for a given Private Key. */
    privateKeyId: string;
  };
  v1GetPrivateKeyResponse: {
    privateKey: definitions["v1PrivateKey"];
  };
  v1GetPrivateKeysRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
  };
  v1GetPrivateKeysResponse: {
    /** @description A list of Private Keys. */
    privateKeys: definitions["v1PrivateKey"][];
  };
  v1GetUserRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    /** @description Unique identifier for a given User. */
    userId: string;
  };
  v1GetUserResponse: {
    user: definitions["v1User"];
  };
  v1GetUsersRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
  };
  v1GetUsersResponse: {
    /** @description A list of Users. */
    users: definitions["v1User"][];
  };
  v1GetWhoamiRequest: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
  };
  v1GetWhoamiResponse: {
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    /** @description Human-readable name for an Organization. */
    organizationName: string;
    /** @description Unique identifier for a given User. */
    userId: string;
    /** @description Human-readable name for a User. */
    username: string;
  };
  /**
   * @description  - HASH_FUNCTION_UNSPECIFIED: Default value if hash function is not set explicitly
   *  - HASH_FUNCTION_NO_OP: No-op function. Useful if you want to pass raw bytes to sign
   *  - HASH_FUNCTION_SHA256: Standard SHA-256
   *  - HASH_FUNCTION_KECCAK256: Keccak-256 (not the same as NIST SHA-3!).
   * This is the hash function used in the Ethereum ecosystem.
   * @enum {string}
   */
  v1HashFunction:
    | "HASH_FUNCTION_NO_OP"
    | "HASH_FUNCTION_SHA256"
    | "HASH_FUNCTION_KECCAK256";
  /** @description Intent object crafted by Turnkey based on the user request, used to assess the permissibility of an action. */
  v1Intent: {
    createOrganizationIntent: definitions["v1CreateOrganizationIntent"];
    createAuthenticatorsIntent?: definitions["v1CreateAuthenticatorsIntent"];
    createUsersIntent?: definitions["v1CreateUsersIntent"];
    createPrivateKeysIntent?: definitions["v1CreatePrivateKeysIntent"];
    signRawPayloadIntent?: definitions["v1SignRawPayloadIntent"];
    createInvitationsIntent?: definitions["v1CreateInvitationsIntent"];
    acceptInvitationIntent?: definitions["v1AcceptInvitationIntent"];
    createPolicyIntent?: definitions["v1CreatePolicyIntent"];
    disablePrivateKeyIntent?: definitions["v1DisablePrivateKeyIntent"];
    deleteUsersIntent?: definitions["v1DeleteUsersIntent"];
    deleteAuthenticatorsIntent?: definitions["v1DeleteAuthenticatorsIntent"];
    deleteInvitationIntent?: definitions["v1DeleteInvitationIntent"];
    deleteOrganizationIntent?: definitions["v1DeleteOrganizationIntent"];
    deletePolicyIntent?: definitions["v1DeletePolicyIntent"];
    createUserTagIntent?: definitions["v1CreateUserTagIntent"];
    deleteUserTagsIntent?: definitions["v1DeleteUserTagsIntent"];
    signTransactionIntent?: definitions["v1SignTransactionIntent"];
    createApiKeysIntent?: definitions["v1CreateApiKeysIntent"];
    deleteApiKeysIntent?: definitions["v1DeleteApiKeysIntent"];
    approveActivityIntent?: definitions["v1ApproveActivityIntent"];
    rejectActivityIntent?: definitions["v1RejectActivityIntent"];
    createPrivateKeyTagIntent?: definitions["v1CreatePrivateKeyTagIntent"];
    deletePrivateKeyTagsIntent?: definitions["v1DeletePrivateKeyTagsIntent"];
    createPolicyIntentV2?: definitions["v1CreatePolicyIntentV2"];
    createPaymentMethodIntent?: definitions["v1CreatePaymentMethodIntent"];
  };
  v1Invitation: {
    /** @description Unique identifier for a given Invitation object. */
    invitationId: string;
    /** @description The name of the intended Invitation recipient. */
    receiverUserName: string;
    /** @description The email address of the intended Invitation recipient. */
    receiverEmail: string;
    /** @description A list of tags assigned to the Invitation recipient. */
    receiverUserTags: string[];
    accessType: definitions["externaldatav1AccessType"];
    status: definitions["v1InvitationStatus"];
    createdAt: definitions["v1Timestamp"];
    updatedAt: definitions["v1Timestamp"];
    /** @description Unique identifier for the Sender of an Invitation. */
    senderUserId: string;
  };
  v1InvitationParams: {
    /**
     * @inject_tag: validate:"required,max=40"
     * @description The name of the intended Invitation recipient.
     */
    receiverUserName: string;
    /**
     * @inject_tag: validate:"required,email"
     * @description The email address of the intended Invitation recipient.
     */
    receiverUserEmail: string;
    /**
     * @inject_tag: validate:"dive,uuid"
     * @description A list of tags assigned to the Invitation recipient.
     */
    receiverUserTags: string[];
    accessType: definitions["immutableactivityv1AccessType"];
    /**
     * @inject_tag: validate:"required,uuid"
     * @description Unique identifier for the Sender of an Invitation.
     */
    senderUserId: string;
  };
  /** @enum {string} */
  v1InvitationStatus:
    | "INVITATION_STATUS_CREATED"
    | "INVITATION_STATUS_ACCEPTED"
    | "INVITATION_STATUS_REVOKED";
  /**
   * @description This proto definition is used in our external-facing APIs.
   * It's important to leverage annotations because they're used in our external interfaces.
   */
  v1OrganizationData: {
    organizationId?: string;
    name?: string;
    users?: definitions["v1User"][];
    policies?: definitions["v1Policy"][];
    privateKeys?: definitions["v1PrivateKey"][];
    invitations?: definitions["v1Invitation"][];
    tags?: definitions["datav1Tag"][];
    deletedUsers?: definitions["v1User"][];
    deletedPolicies?: definitions["v1Policy"][];
    disabledPrivateKeys?: definitions["v1PrivateKey"][];
    deletedInvitations?: definitions["v1Invitation"][];
    deletedApiKeys?: definitions["v1ApiKey"][];
    deletedAuthenticators?: definitions["v1Authenticator"][];
    deletedTags?: definitions["datav1Tag"][];
  };
  /**
   * - PAYLOAD_ENCODING_UNSPECIFIED: Default value if payload encoding is not set explicitly
   *  - PAYLOAD_ENCODING_HEXADECIMAL: Payload is encoded in hexadecimal
   * We accept 0x-prefixed or non-0x prefixed payloads.
   * We accept any casing (uppercase, lowercase, or mixed)
   *  - PAYLOAD_ENCODING_TEXT_UTF8: Payload is encoded as utf-8 text
   * Will be converted to bytes for signature with Rust's standard String.as_bytes()
   * @enum {string}
   */
  v1PayloadEncoding:
    | "PAYLOAD_ENCODING_HEXADECIMAL"
    | "PAYLOAD_ENCODING_TEXT_UTF8";
  v1Policy: {
    /** @description Unique identifier for a given Policy. */
    policyId: string;
    /** @description Human-readable name for a Policy. */
    policyName: string;
    effect: definitions["externaldatav1Effect"];
    /** @description A list of simple functions each including a subject, target and boolean. See Policy Engine Language section for additional details. */
    selectors: definitions["externaldatav1Selector"][];
    createdAt: definitions["v1Timestamp"];
    updatedAt: definitions["v1Timestamp"];
    /** @description Human-readable notes added by a User to describe a particular policy. */
    notes: string;
  };
  v1PrivateKey: {
    /** @description Unique identifier for a given Private Key. */
    privateKeyId: string;
    /** @description The public component of a cryptographic key pair used to sign messages and transactions. */
    publicKey: string;
    /** @description Human-readable name for a Private Key. */
    privateKeyName: string;
    curve: definitions["externaldatav1Curve"];
    /** @description Derived cryptocurrency addresses for a given Private Key. */
    addresses: definitions["externaldatav1Address"][];
    /** @description A list of Private Key Tag IDs. */
    privateKeyTags: string[];
    createdAt: definitions["v1Timestamp"];
  };
  v1PrivateKeyParams: {
    /**
     * @inject_tag: validate:"required,max=40"
     * @description Human-readable name for a Private Key.
     */
    privateKeyName: string;
    curve: definitions["immutableactivityv1Curve"];
    /**
     * @inject_tag: validate:"dive,uuid"
     * @description A list of Private Key Tag IDs.
     */
    privateKeyTags: string[];
    /**
     * @inject_tag: validate:"required"
     * @description Cryptocurrency-specific formats for a derived address (e.g., Ethereum).
     */
    addressFormats: definitions["immutableactivityv1AddressFormat"][];
  };
  v1PublicKeyCredentialWithAttestation: {
    id: string;
    /**
     * Must be literal string "public-key"
     * @enum {string}
     */
    type: "public-key";
    /** ENCODING: base64url */
    rawId: string;
    /** @enum {string} */
    authenticatorAttachment?: "cross-platform" | "platform" | null;
    response: definitions["v1AuthenticatorAttestationResponse"];
    clientExtensionResults: definitions["v1SimpleClientExtensionResults"];
  };
  v1RejectActivityIntent: {
    /**
     * @inject_tag: validate:"required"
     * @description An artifact verifying a User's action.
     */
    fingerprint: string;
  };
  /** @description Result of the intended action. */
  v1Result: {
    createOrganizationResult?: definitions["v1CreateOrganizationResult"];
    createAuthenticatorsResult?: definitions["v1CreateAuthenticatorsResult"];
    createUsersResult?: definitions["v1CreateUsersResult"];
    createPrivateKeysResult?: definitions["v1CreatePrivateKeysResult"];
    createInvitationsResult?: definitions["v1CreateInvitationsResult"];
    acceptInvitationResult?: definitions["v1AcceptInvitationResult"];
    signRawPayloadResult?: definitions["v1SignRawPayloadResult"];
    createPolicyResult?: definitions["v1CreatePolicyResult"];
    disablePrivateKeyResult?: definitions["v1DisablePrivateKeyResult"];
    deleteUsersResult?: definitions["v1DeleteUsersResult"];
    deleteAuthenticatorsResult?: definitions["v1DeleteAuthenticatorsResult"];
    deleteInvitationResult?: definitions["v1DeleteInvitationResult"];
    deleteOrganizationResult?: definitions["v1DeleteOrganizationResult"];
    deletePolicyResult?: definitions["v1DeletePolicyResult"];
    createUserTagResult?: definitions["v1CreateUserTagResult"];
    deleteUserTagsResult?: definitions["v1DeleteUserTagsResult"];
    signTransactionResult?: definitions["v1SignTransactionResult"];
    deleteApiKeysResult?: definitions["v1DeleteApiKeysResult"];
    createApiKeysResult?: definitions["v1CreateApiKeysResult"];
    createPrivateKeyTagResult?: definitions["v1CreatePrivateKeyTagResult"];
    deletePrivateKeyTagsResult?: definitions["v1DeletePrivateKeyTagsResult"];
    createPaymentMethodResult?: definitions["v1CreatePaymentMethodResult"];
  };
  v1SelectorV2: {
    subject?: string;
    operator?: definitions["immutableactivityv1Operator"];
    targets?: string[];
  };
  v1SignRawPayloadIntent: {
    /**
     * @inject_tag: validate:"required,uuid"
     * @description Unique identifier for a given Private Key.
     */
    privateKeyId: string;
    /**
     * @inject_tag: validate:"required"
     * @description Raw unsigned payload to be signed.
     */
    payload: string;
    encoding: definitions["v1PayloadEncoding"];
    hashFunction: definitions["v1HashFunction"];
  };
  v1SignRawPayloadRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1SignRawPayloadIntent"];
  };
  v1SignRawPayloadResult: {
    /** @description Component of an ECSDA signature. */
    r: string;
    /** @description Component of an ECSDA signature. */
    s: string;
    /** @description Component of an ECSDA signature. */
    v: string;
  };
  v1SignTransactionIntent: {
    /**
     * @inject_tag: validate:"required,uuid"
     * @description Unique identifier for a given Private Key.
     */
    privateKeyId: string;
    /**
     * @inject_tag: validate:"required"
     * @description Raw unsigned transaction to be signed by a particular Private Key.
     */
    unsignedTransaction: string;
    type: definitions["immutableactivityv1TransactionType"];
  };
  v1SignTransactionRequest: {
    /** @enum {string} */
    type: "ACTIVITY_TYPE_SIGN_TRANSACTION";
    /** @description Timestamp (in milliseconds) of the request, used to verify liveness of user requests. */
    timestampMs: string;
    /** @description Unique identifier for a given Organization. */
    organizationId: string;
    parameters: definitions["v1SignTransactionIntent"];
  };
  v1SignTransactionResult: {
    signedTransaction: string;
  };
  v1SimpleClientExtensionResults: {
    appid?: boolean;
    appidExclude?: boolean;
    credProps?: definitions["v1CredPropsAuthenticationExtensionsClientOutputs"];
  };
  /** @enum {string} */
  v1TagType: "TAG_TYPE_USER" | "TAG_TYPE_PRIVATE_KEY";
  v1Timestamp: {
    seconds: string;
    nanos: string;
  };
  v1User: {
    /** @description Unique identifier for a given User. */
    userId: string;
    /** @description Human-readable name for a User. */
    userName: string;
    /**
     * some users do not have emails (programmatic users)
     * @description The user's email address.
     */
    userEmail?: string;
    accessType: definitions["externaldatav1AccessType"];
    /** @description A list of Authenticator parameters. */
    authenticators: definitions["v1Authenticator"][];
    /** @description A list of API Key parameters. */
    apiKeys: definitions["v1ApiKey"][];
    /** @description A list of User Tag IDs. */
    userTags: string[];
    createdAt: definitions["v1Timestamp"];
    updatedAt: definitions["v1Timestamp"];
  };
  v1UserParams: {
    /**
     * @inject_tag: validate:"required,max=40"
     * @description Human-readable name for a User.
     */
    userName: string;
    /** @description The user's email address. */
    userEmail?: string;
    accessType: definitions["immutableactivityv1AccessType"];
    /**
     * @inject_tag: validate:"dive,uuid"
     * @description A list of API Key parameters.
     */
    apiKeys: definitions["v1ApiKeyParams"][];
    /**
     * @inject_tag: validate:"dive"
     * @description A list of Authenticator parameters.
     */
    authenticators: definitions["v1AuthenticatorParams"][];
    /**
     * @inject_tag: validate:"dive,uuid"
     * @description A list of User Tag IDs.
     */
    userTags: string[];
  };
  /** @description Object representing a particular User's approval or rejection of a Consensus request, including all relevant metadata. */
  v1Vote: {
    /** @description Unique identifier for a given Vote object. */
    id: string;
    /** @description Unique identifier for a given User. */
    userId: string;
    user: definitions["v1User"];
    /** @description Unique identifier for a given Activity object. */
    activityId: string;
    /** @enum {string} */
    selection: "VOTE_SELECTION_APPROVED" | "VOTE_SELECTION_REJECTED";
    /** @description The raw message being signed within a Vote. */
    message: string;
    /** @description The public component of a cryptographic key pair used to sign messages and transactions. */
    publicKey: string;
    /** @description The signature applied to a particular vote. */
    signature: string;
    /** @description Method used to produce a signature. */
    scheme: string;
    createdAt: definitions["v1Timestamp"];
  };
};

export type operations = {
  /** Get details about an Activity */
  PublicApiService_GetActivity: {
    parameters: {
      body: {
        body: definitions["v1GetActivityRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get details about an Organization */
  PublicApiService_GetOrganization: {
    parameters: {
      body: {
        body: definitions["v1GetOrganizationRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetOrganizationResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get details about a Policy */
  PublicApiService_GetPolicy: {
    parameters: {
      body: {
        body: definitions["v1GetPolicyRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetPolicyResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get details about a User */
  PublicApiService_GetUser: {
    parameters: {
      body: {
        body: definitions["v1GetUserRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetUserResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** List all Activities within an Organization */
  PublicApiService_GetActivities: {
    parameters: {
      body: {
        body: definitions["v1GetActivitiesRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetActivitiesResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** List all Policies within an Organization */
  PublicApiService_GetPolicies: {
    parameters: {
      body: {
        body: definitions["v1GetPoliciesRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetPoliciesResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** List all Private Keys within an Organization */
  PublicApiService_GetPrivateKeys: {
    parameters: {
      body: {
        body: definitions["v1GetPrivateKeysRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetPrivateKeysResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** List all Users within an Organization */
  PublicApiService_GetUsers: {
    parameters: {
      body: {
        body: definitions["v1GetUsersRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetUsersResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get basic information about your current API user and your organization */
  PublicApiService_GetWhoami: {
    parameters: {
      body: {
        body: definitions["v1GetWhoamiRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetWhoamiResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Add api keys to an existing User */
  PublicApiService_CreateApiKeys: {
    parameters: {
      body: {
        body: definitions["v1CreateApiKeysRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create Invitations to join an existing Organization */
  PublicApiService_CreateInvitations: {
    parameters: {
      body: {
        body: definitions["v1CreateInvitationsRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create a new Policy */
  PublicApiService_CreatePolicy: {
    parameters: {
      body: {
        body: definitions["v1CreatePolicyRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create new Private Keys */
  PublicApiService_CreatePrivateKeys: {
    parameters: {
      body: {
        body: definitions["v1CreatePrivateKeysRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Create Users in an existing Organization */
  PublicApiService_CreateUsers: {
    parameters: {
      body: {
        body: definitions["v1CreateUsersRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Remove api keys from a User */
  PublicApiService_DeleteApiKeys: {
    parameters: {
      body: {
        body: definitions["v1DeleteApiKeysRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Delete an existing Invitation */
  PublicApiService_DeleteInvitation: {
    parameters: {
      body: {
        body: definitions["v1DeleteInvitationRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Delete an existing Policy */
  PublicApiService_DeletePolicy: {
    parameters: {
      body: {
        body: definitions["v1DeletePolicyRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Sign a raw payload with a Private Key */
  PublicApiService_SignRawPayload: {
    parameters: {
      body: {
        body: definitions["v1SignRawPayloadRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Sign a transaction with a Private Key */
  PublicApiService_SignTransaction: {
    parameters: {
      body: {
        body: definitions["v1SignTransactionRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1ActivityResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
  /** Get details about a Private Key */
  PublicApiService_GetPrivateKey: {
    parameters: {
      body: {
        body: definitions["v1GetPrivateKeyRequest"];
      };
    };
    responses: {
      /** A successful response. */
      200: {
        schema: definitions["v1GetPrivateKeyResponse"];
      };
      /** Returned when the user does not have permission to access the resource. */
      403: {
        schema: unknown;
      };
      /** Returned when the resource does not exist. */
      404: {
        schema: string;
      };
      /** An unexpected error response. */
      default: {
        schema: definitions["rpcStatus"];
      };
    };
  };
};

export type external = {};
